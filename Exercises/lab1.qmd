---
title: "Exercises: Names and Values"
subtitle: "SDS 270"
author: "Ella Sommerfeld"
format: html
---

## Introduction

For these exercises, we will learn how to use the `lobstr` package to get information about objects in our environment.

**Goal:** By the end of these exercises, you will be able to determine whether an operation makes a copy, and compute the amount of memory each object occupies.

Fill in the code chunks and add written responses for each of the exercises. 

## Exercises

#### Measuring memory

First, load the `lobstr` package. This package contains many functions that will make it easier for us to figure out what R is doing under the hood. Also load the `tidyverse` package.

```{r}
library(lobstr)
library(tidyverse)
```


Your workspace should be empty.

::: {.callout-exercise}
###### Ex. 1:

Use `ls()` to list the objects in your workspace. If it is not empty, use the broom icon in the Environment tab in RStudio to empty it.

:::

```{r}
# Sample solution
ls()
```


Before we do anything, how much memory is being used by our R session?

```{r}
mem_used()
```

155.04 MB

Recall that a byte is eight bits. A byte is a very small amount of information, typically used to store one character. A kilobyte is 1000 bytes, and a megabyte is 1000 kilobytes, etc. You should familiarize yourself briefly with the orders of magnitude of data.

Now suppose we add some things to our workspace. We can add objects, functions, or load packages. Does loading a package increase the memory used by our session?

::: {.callout-exercise}
##### Ex. 2:

Use the `library()` command to load the broom package. Then check the memory usage with `mem_used()`. Does loading a package increase the amount of memory used? By how much?

:::

```{r}
# Fill response here
library(broom)
mem_used()
```

::: {.callout-exercise}

Yes it increases the amount of memory used. It increases my 0.70 MB.

##### Ex. 3:

What about loading a data set? Use the `data()` command to load the `iris` data set. Does that increase the memory usage? By how much?

:::

```{r}
# Fill response here
data("iris")
mem_used()
```

::: {.callout-exercise}

Yes, it increases it by 0.70 MB.

##### Ex. 4:

Use `obj_size()` to measure the amount of memory that `iris` takes up. Was the increase you observed previously equal to this amount?

:::

```{r}
# Fill response here
obj_size(iris)
```

No I observed a 0.70 MB difference while iris takes up 0.0072 MB.

#### Making copies

As much fun as it is to make copies, each copy occupies memory. Generally, we want to minimize the amount of memory that our code needs to run.

Let’s store the amount of memory we are currently using.

```{r}
before <- mem_used()
```

Note the memory location of the `iris` data frame.

```{r}
ref(iris)
```

Note that we can bind a second name `my_iris` to the `iris` data frame, without making a copy.

```{r}
my_iris <- iris
ref(my_iris)
```

Now let’s change the data frame in a way that forces a copy to be made.

```{r}
my_iris <- my_iris |>
  mutate(sepal_area = Sepal.Length * Sepal.Width)
ref(my_iris)
```


Note that the memory locations of `my_iris` and `iris` are not the same anymore. However, the memory locations of the underlying vectors are the same!

::: {.callout-exercise}

##### Ex. 5:

Use `before` and `mem_used()` to calculate how much extra memory the copy of `my_iris` occupies.

:::

```{r}
# Fill response here
mem_used()
157.75-156.43
```

::: {.callout-exercise}

##### Ex. 6:

Is the difference you observed above equal to the size of the new column we created? Why or why not?
No because it is not just the object that is taking up storage there is also the path associated with it.
:::

```{r}
# Fill response here
obj_size(my_iris)
```

Different representations of the same data may have different memory footprints. Suppose we change the iris data set into its long format.

```{r}
iris_long <- iris |>
  pivot_longer(-Species, names_to = "type", values_to = "measurement")
```

::: {.callout-exercise}

##### Ex. 7:

Does `iris_long` take up the same amount of memory as `iris`? Why or why not?
No they do not take up the same amount of memory. This is because information is stored in different ways making it harder or easier to access depending on the format. This also makes it take up more storage.

:::

```{r}
# Fill response here
obj_size(iris_long)
obj_size(iris)
```

We know that tibbles are like `data.frame`s. Do they take up the same amount of memory?

```{r}
before <- mem_used()
iris_tbl <- iris_long |>
  as_tibble()
mem_used() - before

class(iris_tbl)

obj_size(iris_long)
obj_size(iris_tbl)
```

Yes they take up the same amount of storage 13.93 kB.

Does converting a `data.frame` to a `tbl` force a copy?

```{r}
ref(iris_tbl)
ref(iris_long)
```

Yes it does force a copy.

::: {.callout-exercise}

##### Ex. 8:

Discuss how using a tibble changes the memory footprint relative to using a `data.frame`.
Both have different memory locations however the different variables within them (for example in the iris data set Species, type, measurement) share the same location just like a copy. They also both take up the same amount of storage if they are of the same data. So if you were to convert a data frame to tibble you would just be changing the memory location. 

:::

#### Tracing memory

Unfortunately, due to various complications and optimizations, it’s not always possible to reason ahead of time about whether R will make a copy of an object. Instead, we can use the `tracemem()` function to have R tell us whether it makes a copy and why.

First, note the memory location of iris.


```{r}
tracemem(iris)
```

We are now tracing this memory location. Some types of computations we make on `iris` do not require making a copy.

```{r}
iris |>
  pull(Petal.Length) |>
  mean()
```

However, if we modify iris using `mutate()`, a copy does get made.

```{r}
iris |>
  mutate(petal_area = Petal.Length * Petal.Width) |>
  as_tibble()
```

::: {.callout-exercise}

##### Ex. 9:

Experiment with different operations after invoking `tracemem()`. Can you get a feel for what operations induce copies?

```{r}
# Fill response here
tracemem(iris)
iris |>
  select(Sepal.Length, Sepal.Width) |>
  as_tibble()

iris |>
  pull(Sepal.Length) |>
  mean()

iris |>
  filter(Sepal.Length > 0.5)
```


:::

#### Garbage collection

Garbage collection is the process of reclaiming memory that is no longer being used. R does the automatically, but you can force the issue with `gc()`.

```{r}
gc()
```


#### Engagement (optional)

Take a minute to think about what questions you still have about names, values, and copies. Review what questions have been posted (in the #questions channel) recently by other students and either:

- respond (e.g., react, comment, clarify, or answer)
- post a new question

#### Turn in

Save this .qmd file and turn in on Moodle under "Exercises: Names and Values".


```{r}
a <- 1:10
b <- a
c <- b
d <- 1:10
ref(a)
ref(b)
ref(c)
ref(d)

vec <- c(1,2,3,4)
df <-data.frame(1,2,3,4)
mat <- matrix(1,2,3,4)
l1 <- list(1,2,3,4)

obj_size(vec)
obj_size(df)
obj_size(mat)
obj_size(l1)
```

