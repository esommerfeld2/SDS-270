---
title: "Exercises from Class #14: Conditions"
subtitle: "SDS 270"
author: "Ella Sommerfeld"
format: html
---

## Introduction

In this lab, we will learn how to handle conditions.

**Goal:** By the end of this lab, you should be able to handle an error and return from it gracefully.

```{r}
library(tidyverse)
```


## Three types of conditions

Recall that there are three main types of conditions in R:

- **error**: will terminate the function immediately and throw an error
- **warning**: will continue to execute the function, but will warn you about what happened afterwards
- **message**: will immediately display a message about what is happening.

The following function will compute the number of unique values in whatever columns in a data frame you select. The first argument is the data frame, and the second argument is the dots, which are simply passed to `select()`.

Note that this function may display a message, a `warning()`, or an error depending on what happens.

```{r}
unique_values <- function(.data, ...) {
  x <- .data |>
    select(...)
  
  if (ncol(x) == ncol(.data)) {
    warning("All columns selected!")
  }
  
  if (ncol(x) < 1) {
    stop("No columns selected.")
  }

  message(paste("Computing on", ncol(x), "columns..."))  
  map_int(x, n_distinct)
}
```

::: {.callout-important}

### Q1

Examine the code for `unique_values()` carefully. Explain how the function works.

The function takes data and selects certain columns. It throws a warning if all the columns are selected and an error if none are selected. Otherwise it prints a message about which columns it is computing on and then counts the number of unquie values per column. 

:::

If we give this function no valid selection, we will throw an error.

```{r}
#| error: true
unique_values(starwars)
```

::: {.callout-important}

### Q2

Was the error in the previous example thrown by `unique_values()` or by `select()`? How do you know?

It was thrown by unique_values() because the message "No columns selected." is seen in the defining of unique_values. Also select with no columns selected would just result in an empty tibble.  

:::

If we select all of the columns in the data frame, then we get a warning. However, the code still executes.

```{r}
#| error: true
unique_values(starwars, everything())
```

::: {.callout-important}

### Q3

Why does the warning message show up before the results? Why does the warning message show up before the message, when the line of code with `message()` came after the call to `warning()` in the function?

Warning appears at the end because unlike stop() which throws an error the code continues to execute. Then at the end it adds in that the code did encounter a warning along the way. Warnings unlike errors will always continue to execute the code. 

:::

Since `unique_values()` passes the dots to `select()`, we can leverage all of the functionality of the select helpers!

```{r}
#| error: true
unique_values(starwars, contains("n"))
```

However, if we pass garbage to `select()`, then of course `select()` will still throw an error.

```{r}
#| error: true
unique_values(starwars, i_love_r)
```

::: {.callout-important}

### Q4

Consider the difference in the output between the previous example and `unique_values(starwars)`. What is different?

It says was the problem is "Can't select columns that don't exist." but then tells you exactly what column doesn't exist: "Column `i_love_r` doesn't exist." It also includes the message run `rlang::last_trace()` to see where the error occurred.

:::

## Catching errors

Instead of just failing whenever the user passes bad arguments to `select()`, we might want to catch those errors and do something with them. Here, we use a `tryCatch()` statement to provide some additional information about what went wrong, and to continue with the original data frame if the `select()` statement failed.

```{r}
unique_values_safe <- function(.data, ...) {
  x <- tryCatch(
    error = function(cnd) {
      warning("Attempt to select column has failed")
      message("Here is what we know about the error")
      str(cnd)
      .data
    },
    .data |>
      select(...)
  )
  
  if (ncol(x) == ncol(.data)) {
    warning("All columns selected!")
  }
  
  if (ncol(x) < 1) {
    stop("No columns selected.")
  }

  message(paste("Computing on", ncol(x), "columns..."))  
  map_int(x, n_distinct)
}
```

Now, even though an error still occurs, we still get output.

```{r}
#| error: true
unique_values_safe(starwars, i_love_r)
```

Whether this output is sensible is an open question for the developer. In this case I think it is probably not sensible.

::: {.callout-important}

### Q5

Why might it be a better idea to fail with an error in the previous example instead of continuing with the full data frame?

Because you are instead resulting to selecting no columns which is leading to an additional warning and the result is not even close to what you wanted. And if you aren't paying close attention you could continue work with a result that isn't even close to what you wanted. 

:::

## Turn-in

On Moodle, turn in this .qmd file.